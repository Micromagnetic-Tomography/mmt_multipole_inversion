import numpy as np
import time
# import datetime
import json
# from scipy.special import sph_harm
import scipy.linalg as slin
# import warnings
# try:
#     import tensorflow as tf
# except ModuleNotFoundError:
#     warnings.warn('Could not import Tensorflow')
from pathlib import Path

# CUDA modules for populating the suscept matrix (if available)
try:
    from .susceptibility_modules.cuda import cudalib as sus_cudalib
    HASCUDA = True
except ImportError:
    HASCUDA = False

# Suscept modules using Numba:
from . import susceptibility_modules as sus_mods

from typing import Optional
from typing import Literal  # Working with Python >3.8
from typing import Union    # Working with Python >3.8
from . import plot_tools as pt


def dipole_field(dip_r, dip_m, pos_r):
    """
    Calculate magnetic flux B generated by dipole
    with magnetic moment dip_m  (Am2)
    located in position dip_r    (m)
    at position  pos_r           (m)
    unit of result is T
    """
    r = [pos_r[k] - dip_r[k] for k in range(3)]
    rho2 = r[0] * r[0] + r[1] * r[1] + r[2] * r[2]
    rho = np.sqrt(rho2)
    sp = dip_m[0] * r[0] + dip_m[1] * r[1] + dip_m[2] * r[2]
    f = 3e-7 * sp / (rho2 * rho2 * rho)
    g = -1e-7 / (rho2 * rho)
    return([f * r[k] + g * dip_m[k] for k in range(3)])


# -----------------------------------------------------------------------------

SusOptions = Literal['spherical_harmonics_basis',
                     'maxwell_cartesian_polynomials',
                     'cartesian_spherical_harmonics'
                     ]
ExpOptions = Literal['dipole', 'quadrupole', 'octupole']


# TODO: verbose should be more useful for debugging
class MultipoleInversion(object):
    """
    Class to perform multipole inversions of a magnetic scan surface into
    multiple magnetic sources located within a sample. Specifications of
    the scan grid and the magnetic particles in the sample can be generated
    using the `MagneticSample` class.
    """

    def __init__(self,
                 sample_config_file: Union[str, Path],
                 sample_arrays: Optional[Union[str, Path]],  # TODO: set to npz file
                 expansion_limit: ExpOptions = 'quadrupole',
                 verbose: bool = True,
                 sus_functions_module: SusOptions = 'spherical_harmonics_basis'
                 ) -> None:
        """
        Parameters
        ----------
        sample_config_file
            Path to a `json` file with the specifications of the scan grid and
            the magnetic particles. The following keys are mandatory
                Scan height Hz
                Scan area x-dimension Sx
                Scan area y-dimension Sy
                Scan x-step Sdx
                Scan y-step Sdy
                Number of particles
                Time stamp
            Optional:
                Scan origin x
                Scan origin y
        sample_arrays
            An `npz` file containing the scan signal Bz and the particle
            positions (magnetic sources). The file can contain other
            information as well but it is not read here. If the two arrays are
            not specified they can be set manually using the `Bz_array` and
            `particle_positions` class variables.
        expansion_limit
            Higher order multipole term to compute the field contribution from
            the potential of the magnetic particles. Options:
                `dipole`, `quadrupole`, `octupole`
        verbose
            Print extra information about the calculations.
        sus_functions_module
            Spherical harmonic basis for the susceptibility matrix used for the
            multipole inversion. The fully orthogonal and linearly independent
            basis is the `spherical_harmonics_basis`. Other options are not
            orthogonal but might be necessary for comparison. For details see
            the comments in the libraries in the `sus_functions_module/`
            directory and the Notes.

        Notes
        -----
        Mathematical details for the multipole inversion can be found in
            D. Cortés-Ortuño, K. Fabian, L. V. de Groot
            Single Particle Multipole Expansions From Micromagnetic Tomography
            G^3, 22(4), e2021GC009663 (2021)
            https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/2021GC009663

        """

        # Set the module from which to find the Bz susceptibility functions,
        # which is specified using the sus_functions_module argument
        self.sus_mod = getattr(sus_mods, sus_functions_module)

        self._expansion_limit = None
        self.expansion_limit = expansion_limit

        # Turn log messages on/off. TODO: Wrap print into a function to avoid
        # multiple if statements
        self.verbose = verbose

        expected_arrays = ['Bz_array', 'particle_positions']
        self.Bz_array = np.empty(0)
        self.particle_positions = None

        # Any other array in the NPZ file will be loaded here
        if sample_arrays:
            data = np.load(sample_arrays)
            for key, value in data.items():
                setattr(self, key, value)

            for key in expected_arrays:
                if key not in data.keys():
                    if self.verbose:
                        print(f'*{key}* array required for calculations. '
                              ' Set manually.')

        # Optional sequence to set the origin of scan positions
        # self.scan_origin = (0.0, 0.0)

        # Load metadata
        with open(sample_config_file, 'r') as f:
            metadict = json.load(f)

        # TODO: there is a more efficient way to generate the variables from
        # the dictionary
        self.Hz = metadict["Scan height Hz"]
        self.Sx = metadict["Scan area x-dimension Sx"]
        self.Sy = metadict["Scan area y-dimension Sy"]
        self.Sdx = metadict["Scan x-step Sdx"]
        self.Sdy = metadict["Scan y-step Sdy"]
        self.N_particles = metadict["Number of particles"]
        self.time_stamp = metadict["Time stamp"]

        # Set the variables scan_origin_x and scan_origin_y if found in the
        # dictionary, otherwise set them to 0.0
        self.scan_origin_x = metadict.get('Scan origin x', 0.0)
        self.scan_origin_y = metadict.get('Scan origin y', 0.0)

        self.generate_measurement_mesh()

        # Instatiate the forward matrix
        self.Q = np.empty(0)

    @property
    def expansion_limit(self):
        return self._expansion_limit

    @expansion_limit.setter
    def expansion_limit(self, string_value):
        # This will determine the nuber of columns in the forward calculation
        if string_value == 'dipole':
            self._N_cols = 3
        elif string_value == 'quadrupole':
            self._N_cols = 8
        elif string_value == 'octupole':
            self._N_cols = 15
        else:
            raise Exception('Specify a valid expansion limit for the ' +
                            'multipole calculation')
        self._expansion_limit = string_value

    def generate_measurement_mesh(self):
        """
        Generate coordinates for the measurement mesh
        The number of grid points in each direction (xy) are calculated by
        rounding the lateral size by the grid step size, e.g. round(Sx / Sdx)

        """

        # Generate measurement mesh
        self.Sx_range = self.scan_origin_x + np.arange(round(self.Sx / self.Sdx)) * self.Sdx
        self.Sy_range = self.scan_origin_y + np.arange(round(self.Sy / self.Sdy)) * self.Sdy
        self.Nx_surf = len(self.Sx_range)
        self.Ny_surf = len(self.Sy_range)

        if self.verbose:
            print(f'Scanning array size = {len(self.Sx_range)} x {len(self.Sy_range)}')
        self.N_sensors = self.Nx_surf * self.Ny_surf

    def generate_forward_matrix(self, optimization='numba'):
        """
        Generate the forward matrix adding the field contribution from all
        the particles for every grid point at the scan surface. The field is
        computed from the scalar potential of the particles approximated with
        the multipole expansion up to the order specified by
        self.expansion_limit

        Parameters
        ----------
        optimization
            The method to optimize the calculation of the matrix elements:
            `numba` or `cuda`
        """
        # Moment vec m = [mx[0], my[0], mz[0], ... , mx[N-1], my[N-1], mz[N-1]]
        # Position vector  p = [(x[0], y[0]),  ... , x[
        # Generate  forward matrix
        # Q[i, j] =

        # The the total flux array according to the specified expansion limit
        self.Q = np.zeros(shape=(self.N_sensors,
                                 self._N_cols * self.N_particles))

        # print('pos array:', particle_positions.shape)
        t0 = time.time()

        # Create all the positions of the scan grid
        scan_positions = np.ones((self.N_sensors, 3))
        X_pos, Y_pos = np.meshgrid(self.Sx_range, self.Sy_range)
        scan_positions[:, :2] = np.stack((X_pos, Y_pos), axis=2).reshape(-1, 2)
        scan_positions[:, 2] *= self.Hz

        if optimization == 'cuda':
            mp_order = {'dipole': 1, 'quadrupole': 2, 'octupole': 3}
            if HASCUDA is False:
                raise Exception('The cuda method is not available. Stopping calculation')

            sus_cudalib.SHB_populate_matrix(self.particle_positions,
                                            scan_positions, 
                                            self.Q,
                                            self.N_particles, self.N_sensors,
                                            mp_order[self.expansion_limit],
                                            self.verbose)

        # For all the particles, whose positions are stored in the pos array
        # (N_particles x 3), compute the dipole (3 terms), quadrupole (5 terms)
        # or octupole (7 terms) contributions. Here we populate the Q array
        # using the numba-optimised susceptibility functions
        elif optimization == 'numba':
            self.sus_mod.dipole_Bz_sus(self.particle_positions, scan_positions,
                                       self.Q, self._N_cols)
            if self.expansion_limit in ['quadrupole', 'octupole']:
                self.sus_mod.quadrupole_Bz_sus(self.particle_positions,
                                               scan_positions,
                                               self.Q, self._N_cols)
            if self.expansion_limit in ['octupole']:
                self.sus_mod.octupole_Bz_sus(self.particle_positions,
                                             scan_positions,
                                             self.Q, self._N_cols)

        t1 = time.time()
        if self.verbose:
            print(f'Generation of Q matrix took: {t1 - t0:.4f} s')
        # print('Q shape:', Q.shape)

    def compute_inversion(self,
                          method='sp_pinv',
                          **method_kwargs
                          ):
        """
        Computes the multipole inversion. Results are saved in the
        `inv_multipole_moments` and `inv_Bz_array` variables. This method
        requires the generation of the `Q` matrix, hence the
        `generate_forward_matrix` method using `numba` is called if `Q` has not
        been set. To optimize the calculation of `Q`, call the function before
        this method.

        Parameters
        ----------
        method
            The numerical method to perform the inversion. Options:
                np_pinv  -> Numpy's pinv
                sp_pinv  -> Scipy's pinv (not recommended -> memory issues)
                sp_pinv2 -> Scipy's pinv2 (this will call sp_pinv instead)
        **method_kwargs
            Extra parameters passed to Numpy or Scipy functions. For Numpy, the
            tolerance can be set using `rcond` while for `Scipy` it is
            recommended to use `atol` and `rtol`. See their documentations for
            detailed information.
        """
        if self.Q.size == 0:
            if self.verbose:
                print('Generating forward matrix')
            self.generate_forward_matrix()

        if method == 'np_pinv':
            if self.verbose:
                print('Using numpy.pinv for inversion')
            self.IQ = np.linalg.pinv(self.Q, **method_kwargs)
        elif method == 'sp_pinv' or method == 'sp_pinv2':
            if self.verbose:
                print('Using scipy.linalg.pinv for inversion')
            self.IQ = slin.pinv(self.Q, **method_kwargs)
        # elif method == 'tf_pinv':
        #     if self.verbose:
        #         print('Using tf.linalg.pinv for inversion')
        #     self.IQ = tf.linalg.pinv(self.Q, rcond=rcond, **method_kwargs)
        else:
            raise TypeError(f'Method {method} not implemented')

        # print('Bz_data shape OLD:', Bz_array.shape)
        Bz_Data = np.reshape(self.Bz_array, self.N_sensors, order='C')
        # print('Bz_data shape:', Bz_Data.shape)
        # print('IQ shape:', IQ.shape)
        self.inv_multipole_moments = np.dot(self.IQ, Bz_Data)
        self.inv_multipole_moments.shape = (self.N_particles, self._N_cols)
        # print('mags:', mags.shape)

        # Forward field
        self.inv_Bz_array = np.matmul(self.Q,
                                      self.inv_multipole_moments.reshape(-1))
        self.inv_Bz_array.shape = (self.Ny_surf, -1)

    def save_multipole_moments(self, save_name='TIME_STAMP', basedir='.'):
        """
        Save the multipole values in `npz` files. Values are computed from the
        inversion using the `compute_inversion` method.
        """
        BASEDIR = Path(basedir)
        if save_name == 'TIME_STAMP':
            fname = BASEDIR / f'InvMagQuad_{self.time_stamp}.npz'
        else:
            fname = BASEDIR / f'InvMagQuad_{save_name}.npz'
        np.savez(fname, inv_multipole_moments=self.inv_multipole_moments)


# PLOTS -----------------------------------------------------------------------
# These functions have been moved to the plot_tools module but will be left
# here (for a while) for compatibility
# (UNDOCUMENTED)

def plot_sample(Inversion, ax,
                contourf_args={'levels': 50},
                contour_args={},
                scatter_args={'c': 'k', 's': 1},
                imshow_args=None,
                dimension_scale=1., data_scale=1.,
                ):

    cf, sc, conts = pt.plot_sample(ax,
                                   Inversion.Bz_array,
                                   Inversion.Sx_range, Inversion.Sy_range,
                                   Inversion.Sdx, Inversion.Sdy,
                                   Inversion.particle_positions,
                                   contourf_args=contourf_args,
                                   contour_args=contour_args,
                                   scatter_args=scatter_args,
                                   imshow_args=imshow_args,
                                   dimension_scale=dimension_scale,
                                   data_scale=data_scale)
    return cf, sc


def plot_inversion_Bz(Inversion, ax, contours=20, contourlines=10,
                      dimension_scale=1., data_scale=1.,
                      #
                      imshow_args=None,
                      contourf_args={'cmap': 'RdYlBu'},
                      #
                      contour_args={'colors': 'k', 'linewidths': .2},
                      scatter_args={'c': 'k'}
                      ):

    contour_args_mod = {**contour_args, 'levels': contourlines}
    contourf_args_mod = {**contourf_args, 'levels': contours}
    cf, c1, c2 = pt.plot_inversion_Bz(ax,
                                      Inversion.inv_Bz_array,
                                      Inversion.Sx_range, Inversion.Sy_range,
                                      Inversion.Sdx, Inversion.Sdy,
                                      Inversion.particle_positions,
                                      dimension_scale=dimension_scale,
                                      data_scale=data_scale,
                                      imshow_args=imshow_args,
                                      contourf_args=contourf_args_mod,
                                      contour_args=contour_args_mod,
                                      scatter_args=scatter_args)

    return cf, c1, c2


def plot_difference_Bz(Inversion, ax, contours=50,
                       dimension_scale=1., data_scale=1.,
                       contourf_args={'cmap': 'RdYlBu'},
                       imshow_args=None,
                       scatter_args={'c': 'k', 's': 1}
                       ):

    # use the contours argument for the number of levels (old code!)
    # so update the contourf_args dictionary
    contourf_args_mod = {**contourf_args, 'levels': contours}
    cf, c1 = pt.plot_difference_Bz(ax,
                                   Inversion.Bz_array, Inversion.inv_Bz_array,
                                   Inversion.Sx_range, Inversion.Sy_range,
                                   Inversion.Sdx, Inversion.Sdy,
                                   Inversion.particle_positions,
                                   dimension_scale=dimension_scale,
                                   data_scale=data_scale,
                                   contourf_args=contourf_args_mod,
                                   imshow_args=imshow_args,
                                   scatter_args=scatter_args)

    return cf, c1
