import numpy as np
import matplotlib.pyplot as plt
# from palettable.cartocolors.diverging import Geyser_5
import time
# import datetime
import json
# from scipy.special import sph_harm
import sys
import scipy.linalg as slin
import warnings
# try:
#     import tensorflow as tf
# except ModuleNotFoundError:
#     warnings.warn('Could not import Tensorflow')
from pathlib import Path

from . import susceptibility_modules as sus_mods
from typing import Optional
from typing import Literal  # Working with Python >3.8


def dipole_field(dip_r, dip_m, pos_r):
    """
    Calculate magnetic flux B generated by dipole
    with magnetic moment dip_m  (Am2)
    located in position dip_r    (m)
    at position  pos_r           (m)
    unit of result is T
    """
    r = [pos_r[k] - dip_r[k] for k in range(3)]
    rho2 = r[0] * r[0] + r[1] * r[1] + r[2] * r[2]
    rho = np.sqrt(rho2)
    sp = dip_m[0] * r[0] + dip_m[1] * r[1] + dip_m[2] * r[2]
    f = 3e-7 * sp / (rho2 * rho2 * rho)
    g = -1e-7 / (rho2 * rho)
    return([f * r[k] + g * dip_m[k] for k in range(3)])


# -----------------------------------------------------------------------------

SusOptions = Literal['spherical_harmonics_basis',
                     'maxwell_cartesian_polynomials',
                     'cartesian_speherical_harmonics'
                     ]
ExpOptions = Literal['dipole', 'quadrupole', 'octupole']


class MultipoleInversion(object):
    """
    """

    def __init__(self,
                 sample_config_file: str,
                 sample_arrays: Optional[str],  # TODO: set to npz file
                 expansion_limit: ExpOptions = 'quadrupole',
                 verbose: bool = True,
                 sus_functions_module: SusOptions = 'spherical_harmonics_basis'
                 ) -> None:
        """
        sample_config_file  ::
        sample_arrays       :: An npz file with, at least, the
        expansion_limit     :: 'dipole', 'quadrupole', 'octupole'
                                Higher order multipole term to compute the
                                field contribution from the potential of the
                                magnetic particles
        verbose             ::
        """

        # Set the module from which to find the Bz susceptibility functions,
        # which is specified using the sus_functions_module argument
        self.sus_mod = getattr(sus_mods, sus_functions_module)

        self._expansion_limit = None
        self.expansion_limit = expansion_limit

        # Turn log messages on/off. TODO: Wrap print into a function to avoid
        # multiple if statements
        self.verbose = verbose

        expected_arrays = ['Bz_array', 'particle_positions']
        self.Bz_array = None
        self.particle_positions = None

        # Any other array in the NPZ file will be loaded here
        if sample_arrays:
            data = np.load(sample_arrays)
            for key, value in data.items():
                setattr(self, key, value)

            for key in expected_arrays:
                if key not in data.keys():
                    if self.verbose:
                        print(f'*{key}* array required for calculations. '
                              ' Set manually.')

        # Optional sequence to set the origin of scan positions
        self.scan_origin = (0.0, 0.0)

        # Load metadata
        with open(sample_config_file, 'r') as f:
            metadict = json.load(f)

        # TODO: there is a more efficient way to generate the variables from
        # the dictionary
        self.Hz = metadict["Scan height Hz"]
        self.Sx = metadict["Scan area x-dimension Sx"]
        self.Sy = metadict["Scan area y-dimension Sy"]
        self.Sdx = metadict["Scan x-step Sdx"]
        self.Sdy = metadict["Scan y-step Sdy"]
        self.N_particles = metadict["Number of particles"]
        self.time_stamp = metadict["Time stamp"]

        # Set the variables scan_origin_x and scan_origin_y if found in the
        # dictionary, otherwise set them to 0.0
        for k in ['Scan origin x', 'Scan origin y']:
            attr = k.lower().replace(' ', '_')
            if k in metadict.keys():
                setattr(self, attr, metadict[k])
            else:
                setattr(self, attr, 0.0)

        self.generate_measurement_mesh()

        # Instatiate the forward matrix
        self.Q = None

    @property
    def expansion_limit(self):
        return self._expansion_limit

    @expansion_limit.setter
    def expansion_limit(self, string_value):
        # This will determine the nuber of columns in the forward calculation
        if string_value == 'dipole':
            self._N_cols = 3
        elif string_value == 'quadrupole':
            self._N_cols = 8
        elif string_value == 'octupole':
            self._N_cols = 15
        else:
            raise Exception('Specify a valid expansion limit for the ' +
                            'multipole calculation')
        self._expansion_limit = string_value

    def generate_measurement_mesh(self):
        """
        Generate coordinates for the measurement mesh
        The number of grid points in each direction (xy) are calculated by
        rounding the lateral size by the grid step size, e.g. round(Sx / Sdx)
        """

        # Generate measurement mesh
        self.Sx_range = self.scan_origin_x + np.arange(round(self.Sx / self.Sdx)) * self.Sdx
        self.Sy_range = self.scan_origin_y + np.arange(round(self.Sy / self.Sdy)) * self.Sdy
        self.Nx_surf = len(self.Sx_range)
        self.Ny_surf = len(self.Sy_range)

        if self.verbose:
            print(f'Scanning array size = {len(self.Sx_range)} x {len(self.Sy_range)}')
        self.N_Points = self.Nx_surf * self.Ny_surf

    def generate_forward_matrix(self):
        """
        Generate the forward matrix adding the field contribution from all
        the particles for every grid point at the scan surface. The field is
        computed from the scalar potential of the particles approximated with
        the multipole expansion up to the order specified by
        self.expansion_limit
        """
        # Moment vector m = [mx[0], my[0], mz[0], ... , mx[N-1], my[N-1], mz[N-1] ]
        # Position vector  p = [(x[0], y[0]),  ... , x[
        # Generate  forward matrix
        # Q[i, j] =

        # The the total flux array according to the specified expansion limit
        self.Q = np.zeros(shape=(self.N_Points,
                                 self._N_cols * self.N_particles))

        # print('pos array:', particle_positions.shape)
        t0 = time.time()

        # Create all the positions of the scan array
        pos = np.ones((self.N_Points, 3))
        X_pos, Y_pos = np.meshgrid(self.Sx_range, self.Sy_range)
        pos[:, :2] = np.stack((X_pos, Y_pos), axis=2).reshape(-1, 2)
        pos[:, 2] *= self.Hz

        # For all the particles, whose positions are stored in the pos array
        # (N_particles x 3), compute the dipole (3 terms), quadrupole (5 terms)
        # or octupole (7 terms) contributions. Here we populate the Q array
        # using the numba-optimised susceptibility functions
        self.sus_mod.dipole_Bz_sus(self.particle_positions, pos,
                                   self.Q, self._N_cols)
        if self.expansion_limit in ['quadrupole', 'octupole']:
            self.sus_mod.quadrupole_Bz_sus(self.particle_positions, pos,
                                           self.Q, self._N_cols)
        if self.expansion_limit in ['octupole']:
            self.sus_mod.octupole_Bz_sus(self.particle_positions, pos,
                                         self.Q, self._N_cols)

        t1 = time.time()
        if self.verbose:
            print(f'Generation of Q matrix took: {t1 - t0:.4f} s')
        # print('Q shape:', Q.shape)

    def compute_inversion(self, method='sp_pinv2',
                          save_multipole_moments='TIME_STAMP',
                          basedir='.',
                          rcond=1e-15,
                          **method_kwargs
                          ):
        """
        Requires generation of Q matrix

        method      :: The numerical method to perform the inversion. Options:

                       np_pinv2 -> Numpy's pinv2
                       sp_pinv  -> Scipy's pinv (not recommended -> memory issues)
                       sp_pinv2 -> Scipy's pinv2
        """
        if self.Q is None:
            if self.verbose:
                print('Generating forward matrix')
            self.generate_forward_matrix()

        if method == 'np_pinv':
            if self.verbose:
                print('Using numpy.pinv for inversion')
            self.IQ = np.linalg.pinv(self.Q, rcond=rcond, **method_kwargs)
        elif method == 'sp_pinv':
            if self.verbose:
                print('Using scipy.linalg.pinv for inversion')
            self.IQ = slin.pinv(self.Q, rcond=rcond, **method_kwargs)
        elif method == 'sp_pinv2':
            if self.verbose:
                print('Using scipy.linalg.pinv2 for inversion')
            self.IQ = slin.pinv2(self.Q, rcond=rcond, **method_kwargs)
        # elif method == 'tf_pinv':
        #     if self.verbose:
        #         print('Using tf.linalg.pinv for inversion')
        #     self.IQ = tf.linalg.pinv(self.Q, rcond=rcond, **method_kwargs)
        else:
            raise TypeError(f'Method {method} not implemented')

        # print('Bz_data shape OLD:', Bz_array.shape)
        Bz_Data = np.reshape(self.Bz_array, self.N_Points, order='C')
        # print('Bz_data shape:', Bz_Data.shape)
        # print('IQ shape:', IQ.shape)
        self.inv_multipole_moments = np.dot(self.IQ, Bz_Data)
        self.inv_multipole_moments.shape = (self.N_particles, self._N_cols)
        # print('mags:', mags.shape)

        if save_multipole_moments:
            BASEDIR = Path(basedir)
            if save_multipole_moments == 'TIME_STAMP':
                fname = BASEDIR / f'InvMagQuad_{self.time_stamp}.npz'
            else:
                fname = BASEDIR / f'InvMagQuad_{save_multipole_moments}.npz'
            np.savez(fname, self.inv_multipole_moments)

        # Forward field
        self.inv_Bz_array = np.matmul(self.Q,
                                      self.inv_multipole_moments.reshape(-1))
        self.inv_Bz_array.shape = (self.Ny_surf, -1)


# PLOTS -----------------------------------------------------------------------


def plot_sample(Inversion, ax,
                contourf_args={'levels': 50},
                contour_args={},
                scatter_args={'c': 'k', 's': 1},
                imshow_args=None,
                dimension_scale=1., data_scale=1.,
                ):

    dms = dimension_scale
    dds = data_scale

    if not imshow_args:
        cf = ax.contourf(Inversion.Sx_range * dms, Inversion.Sy_range * dms,
                         Inversion.Bz_array * dds,
                         **contourf_args)
    else:
        dx, dy = Inversion.Sdx * dms * 0.5, Inversion.Sdy * dms * 0.5
        cf = ax.imshow(Inversion.Bz_array * dds,
                       origin='lower',
                       extent=[Inversion.Sx_range.min() * dms - dx,
                               Inversion.Sx_range.max() * dms + dx,
                               Inversion.Sy_range.min() * dms - dy,
                               Inversion.Sy_range.max() * dms + dy],
                       **imshow_args)

    if contour_args:
        ax.contour(Inversion.Sx_range * dms, Inversion.Sy_range * dms,
                   Inversion.Bz_array * dds,
                   **contour_args)

    sc = ax.scatter(Inversion.particle_positions[:, 0] * dms,
                    Inversion.particle_positions[:, 1] * dms,
                    **scatter_args)
    return cf, sc


def plot_inversion_Bz(Inversion, ax, contours=20, contourlines=10,
                      dimension_scale=1., data_scale=1.,
                      #
                      imshow_args=None,
                      contourf_args={'cmap': 'RdYlBu'},
                      #
                      contour_args={'colors': 'k', 'linewidths': .2},
                      scatter_args={'c': 'k'}
                      ):
    """
    Given a matplotlib axis, plot the inverted field Bz on it, and the
    positions of the particles

    Optional:

        If imshow_args is specified, this functions uses imshow instead
        of contourf to plot the colored background with Bz_array. In this
        case, all the contourf args are ignored
    """

    dms = dimension_scale
    dds = data_scale

    # plt.imshow(computed_FF.reshape(100, 101))
    # plt.colorbar()
    if not imshow_args:
        cf = ax.contourf(Inversion.Sx_range * dms, Inversion.Sy_range * dms,
                         Inversion.inv_Bz_array * dds, levels=contours,
                         **contourf_args)
    else:
        dx, dy = 0.5 * Inversion.Sdx * dms, 0.5 * Inversion.Sdy * dms
        cf = ax.imshow(Inversion.inv_Bz_array * dds,
                       origin='lower',
                       extent=[Inversion.Sx_range.min() * dms - dx,
                               Inversion.Sx_range.max() * dms + dx,
                               Inversion.Sy_range.min() * dms - dy,
                               Inversion.Sy_range.max() * dms + dy],
                       **imshow_args)

    c1 = ax.contour(Inversion.Sx_range * dms, Inversion.Sy_range * dms,
                    Inversion.inv_Bz_array * dds, levels=contourlines,
                    **contour_args)
    c2 = ax.scatter(Inversion.particle_positions[:, 0] * dms,
                    Inversion.particle_positions[:, 1] * dms,
                    **scatter_args)
    # plt.savefig(f'FORWARD_scanning_array_{ts}.pdf', bbox_inches='tight')

    return cf, c1, c2


def plot_difference_Bz(Inversion, ax, contours=50,
                       dimension_scale=1., data_scale=1.,
                       contourf_args={'cmap': 'RdYlBu'},
                       imshow_args=None,
                       scatter_args={'c': 'k', 's': 1}
                       ):

    dms = dimension_scale
    dds = data_scale

    # plt.imshow((computed_FF - Bz_Data).reshape(100, 101))
    if not imshow_args:
        cf = ax.contourf(Inversion.Sx_range * dms, Inversion.Sy_range * dms,
                         (Inversion.inv_Bz_array - Inversion.Bz_array) * dds,
                         contours,
                         **contourf_args)
    else:
        dx, dy = 0.5 * Inversion.Sdx * dms, 0.5 * Inversion.Sdy * dms
        cf = ax.imshow((Inversion.inv_Bz_array - Inversion.Bz_array) * dds,
                       origin='lower',
                       extent=[Inversion.Sx_range.min() * dms - dx,
                               Inversion.Sx_range.max() * dms + dx,
                               Inversion.Sy_range.min() * dms - dy,
                               Inversion.Sy_range.max() * dms + dy],
                       **imshow_args)

    c1 = ax.scatter(Inversion.particle_positions[:, 0] * dms,
                    Inversion.particle_positions[:, 1] * dms,
                    **scatter_args)
    # plt.savefig(f'ERROR_scanning_array_{ts}.pdf', bbox_inches='tight')
    # plt.show()

    return cf, c1
