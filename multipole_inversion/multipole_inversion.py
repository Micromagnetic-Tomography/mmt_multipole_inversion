import numpy as np
# from palettable.cartocolors.diverging import Geyser_5
import time
# import datetime
import json
# from scipy.special import sph_harm
import sys
import scipy.linalg as slin
# import warnings
# try:
#     import tensorflow as tf
# except ModuleNotFoundError:
#     warnings.warn('Could not import Tensorflow')
from pathlib import Path

from . import susceptibility_modules as sus_mods
from typing import Optional
from typing import Literal  # Working with Python >3.8
from typing import Union    # Working with Python >3.8
from . import plot_tools as pt


def dipole_field(dip_r, dip_m, pos_r):
    """
    Calculate magnetic flux B generated by dipole
    with magnetic moment dip_m  (Am2)
    located in position dip_r    (m)
    at position  pos_r           (m)
    unit of result is T
    """
    r = [pos_r[k] - dip_r[k] for k in range(3)]
    rho2 = r[0] * r[0] + r[1] * r[1] + r[2] * r[2]
    rho = np.sqrt(rho2)
    sp = dip_m[0] * r[0] + dip_m[1] * r[1] + dip_m[2] * r[2]
    f = 3e-7 * sp / (rho2 * rho2 * rho)
    g = -1e-7 / (rho2 * rho)
    return([f * r[k] + g * dip_m[k] for k in range(3)])


# -----------------------------------------------------------------------------

SusOptions = Literal['spherical_harmonics_basis',
                     'maxwell_cartesian_polynomials',
                     'cartesian_spherical_harmonics'
                     ]
ExpOptions = Literal['dipole', 'quadrupole', 'octupole']


class MultipoleInversion(object):
    """
    """

    def __init__(self,
                 sample_config_file: Union[str, Path],
                 sample_arrays: Optional[Union[str, Path]],  # TODO: set to npz file
                 expansion_limit: ExpOptions = 'quadrupole',
                 verbose: bool = True,
                 sus_functions_module: SusOptions = 'spherical_harmonics_basis'
                 ) -> None:
        """
        sample_config_file  ::
        sample_arrays       :: An npz file with, at least, the scan signal Bz
                               and the particle positions (magnetic sources)
        expansion_limit     :: 'dipole', 'quadrupole', 'octupole'
                                Higher order multipole term to compute the
                                field contribution from the potential of the
                                magnetic particles
        verbose             ::
        """

        # Set the module from which to find the Bz susceptibility functions,
        # which is specified using the sus_functions_module argument
        self.sus_mod = getattr(sus_mods, sus_functions_module)

        self._expansion_limit = None
        self.expansion_limit = expansion_limit

        # Turn log messages on/off. TODO: Wrap print into a function to avoid
        # multiple if statements
        self.verbose = verbose

        expected_arrays = ['Bz_array', 'particle_positions']
        self.Bz_array = None
        self.particle_positions = None

        # Any other array in the NPZ file will be loaded here
        if sample_arrays:
            data = np.load(sample_arrays)
            for key, value in data.items():
                setattr(self, key, value)

            for key in expected_arrays:
                if key not in data.keys():
                    if self.verbose:
                        print(f'*{key}* array required for calculations. '
                              ' Set manually.')

        # Optional sequence to set the origin of scan positions
        # self.scan_origin = (0.0, 0.0)

        # Load metadata
        with open(sample_config_file, 'r') as f:
            metadict = json.load(f)

        # TODO: there is a more efficient way to generate the variables from
        # the dictionary
        self.Hz = metadict["Scan height Hz"]
        self.Sx = metadict["Scan area x-dimension Sx"]
        self.Sy = metadict["Scan area y-dimension Sy"]
        self.Sdx = metadict["Scan x-step Sdx"]
        self.Sdy = metadict["Scan y-step Sdy"]
        self.N_particles = metadict["Number of particles"]
        self.time_stamp = metadict["Time stamp"]

        # Set the variables scan_origin_x and scan_origin_y if found in the
        # dictionary, otherwise set them to 0.0
        self.scan_origin_x = metadict.get('Scan origin x', 0.0)
        self.scan_origin_y = metadict.get('Scan origin y', 0.0)

        self.generate_measurement_mesh()

        # Instatiate the forward matrix
        self.Q = None

    @property
    def expansion_limit(self):
        return self._expansion_limit

    @expansion_limit.setter
    def expansion_limit(self, string_value):
        # This will determine the nuber of columns in the forward calculation
        if string_value == 'dipole':
            self._N_cols = 3
        elif string_value == 'quadrupole':
            self._N_cols = 8
        elif string_value == 'octupole':
            self._N_cols = 15
        else:
            raise Exception('Specify a valid expansion limit for the ' +
                            'multipole calculation')
        self._expansion_limit = string_value

    def generate_measurement_mesh(self):
        """
        Generate coordinates for the measurement mesh
        The number of grid points in each direction (xy) are calculated by
        rounding the lateral size by the grid step size, e.g. round(Sx / Sdx)
        """

        # Generate measurement mesh
        self.Sx_range = self.scan_origin_x + np.arange(round(self.Sx / self.Sdx)) * self.Sdx
        self.Sy_range = self.scan_origin_y + np.arange(round(self.Sy / self.Sdy)) * self.Sdy
        self.Nx_surf = len(self.Sx_range)
        self.Ny_surf = len(self.Sy_range)

        if self.verbose:
            print(f'Scanning array size = {len(self.Sx_range)} x {len(self.Sy_range)}')
        self.N_Points = self.Nx_surf * self.Ny_surf

    def generate_forward_matrix(self):
        """
        Generate the forward matrix adding the field contribution from all
        the particles for every grid point at the scan surface. The field is
        computed from the scalar potential of the particles approximated with
        the multipole expansion up to the order specified by
        self.expansion_limit
        """
        # Moment vector m = [mx[0], my[0], mz[0], ... , mx[N-1], my[N-1], mz[N-1] ]
        # Position vector  p = [(x[0], y[0]),  ... , x[
        # Generate  forward matrix
        # Q[i, j] =

        # The the total flux array according to the specified expansion limit
        self.Q = np.zeros(shape=(self.N_Points,
                                 self._N_cols * self.N_particles))

        # print('pos array:', particle_positions.shape)
        t0 = time.time()

        # Create all the positions of the scan grid
        scan_positions = np.ones((self.N_Points, 3))
        X_pos, Y_pos = np.meshgrid(self.Sx_range, self.Sy_range)
        scan_positions[:, :2] = np.stack((X_pos, Y_pos), axis=2).reshape(-1, 2)
        scan_positions[:, 2] *= self.Hz

        # For all the particles, whose positions are stored in the pos array
        # (N_particles x 3), compute the dipole (3 terms), quadrupole (5 terms)
        # or octupole (7 terms) contributions. Here we populate the Q array
        # using the numba-optimised susceptibility functions
        self.sus_mod.dipole_Bz_sus(self.particle_positions, scan_positions,
                                   self.Q, self._N_cols)
        if self.expansion_limit in ['quadrupole', 'octupole']:
            self.sus_mod.quadrupole_Bz_sus(self.particle_positions,
                                           scan_positions,
                                           self.Q, self._N_cols)
        if self.expansion_limit in ['octupole']:
            self.sus_mod.octupole_Bz_sus(self.particle_positions,
                                         scan_positions,
                                         self.Q, self._N_cols)

        t1 = time.time()
        if self.verbose:
            print(f'Generation of Q matrix took: {t1 - t0:.4f} s')
        # print('Q shape:', Q.shape)

    def compute_inversion(self, method='sp_pinv2',
                          rcond=1e-15,
                          **method_kwargs
                          ):
        """
        Requires generation of Q matrix

        method      :: The numerical method to perform the inversion. Options:

                       np_pinv  -> Numpy's pinv
                       sp_pinv  -> Scipy's pinv (not recommended -> memory issues)
                       sp_pinv2 -> Scipy's pinv2
        """
        if self.Q is None:
            if self.verbose:
                print('Generating forward matrix')
            self.generate_forward_matrix()

        if method == 'np_pinv':
            if self.verbose:
                print('Using numpy.pinv for inversion')
            self.IQ = np.linalg.pinv(self.Q, rcond=rcond, **method_kwargs)
        elif method == 'sp_pinv':
            if self.verbose:
                print('Using scipy.linalg.pinv for inversion')
            self.IQ = slin.pinv(self.Q, rcond=rcond, **method_kwargs)
        elif method == 'sp_pinv2':
            if self.verbose:
                print('Using scipy.linalg.pinv2 for inversion')
            self.IQ = slin.pinv2(self.Q, rcond=rcond, **method_kwargs)
        # elif method == 'tf_pinv':
        #     if self.verbose:
        #         print('Using tf.linalg.pinv for inversion')
        #     self.IQ = tf.linalg.pinv(self.Q, rcond=rcond, **method_kwargs)
        else:
            raise TypeError(f'Method {method} not implemented')

        # print('Bz_data shape OLD:', Bz_array.shape)
        Bz_Data = np.reshape(self.Bz_array, self.N_Points, order='C')
        # print('Bz_data shape:', Bz_Data.shape)
        # print('IQ shape:', IQ.shape)
        self.inv_multipole_moments = np.dot(self.IQ, Bz_Data)
        self.inv_multipole_moments.shape = (self.N_particles, self._N_cols)
        # print('mags:', mags.shape)

        # Forward field
        self.inv_Bz_array = np.matmul(self.Q,
                                      self.inv_multipole_moments.reshape(-1))
        self.inv_Bz_array.shape = (self.Ny_surf, -1)

    def save_multipole_moments(self, save_name='TIME_STAMP', basedir='.'):
        """
        Save the multipole values computed from the inversion using
        the self.compute_inversion method.
        """
        BASEDIR = Path(basedir)
        if save_name == 'TIME_STAMP':
            fname = BASEDIR / f'InvMagQuad_{self.time_stamp}.npz'
        else:
            fname = BASEDIR / f'InvMagQuad_{save_name}.npz'
        np.savez(fname, inv_multipole_moments=self.inv_multipole_moments)


# PLOTS -----------------------------------------------------------------------
# These functions have been moved to the plot_tools module but will be left
# here (for a while) for compatibility

def plot_sample(Inversion, ax,
                contourf_args={'levels': 50},
                contour_args={},
                scatter_args={'c': 'k', 's': 1},
                imshow_args=None,
                dimension_scale=1., data_scale=1.,
                ):

    cf, sc = pt.plot_sample(ax,
                            Inversion.Bz_array,
                            Inversion.Sx_range, Inversion.Sy_range,
                            Inversion.Sdx, Inversion.Sdy,
                            Inversion.particle_positions,
                            contourf_args=contourf_args,
                            contour_args=contour_args,
                            scatter_args=scatter_args,
                            imshow_args=imshow_args,
                            dimension_scale=dimension_scale,
                            data_scale=data_scale)
    return cf, sc


def plot_inversion_Bz(Inversion, ax, contours=20, contourlines=10,
                      dimension_scale=1., data_scale=1.,
                      #
                      imshow_args=None,
                      contourf_args={'cmap': 'RdYlBu'},
                      #
                      contour_args={'colors': 'k', 'linewidths': .2},
                      scatter_args={'c': 'k'}
                      ):

    contour_args_mod = {**contour_args, 'levels': contourlines}
    contourf_args_mod = {**contourf_args, 'levels': contours}
    cf, c1, c2 = pt.plot_inversion_Bz(ax,
                                      Inversion.inv_Bz_array,
                                      Inversion.Sx_range, Inversion.Sy_range,
                                      Inversion.Sdx, Inversion.Sdy,
                                      Inversion.particle_positions,
                                      dimension_scale=dimension_scale,
                                      data_scale=data_scale,
                                      imshow_args=imshow_args,
                                      contourf_args=contourf_args_mod,
                                      contour_args=contour_args_mod,
                                      scatter_args=scatter_args)

    return cf, c1, c2


def plot_difference_Bz(Inversion, ax, contours=50,
                       dimension_scale=1., data_scale=1.,
                       contourf_args={'cmap': 'RdYlBu'},
                       imshow_args=None,
                       scatter_args={'c': 'k', 's': 1}
                       ):

    contourf_args_mod = {**contourf_args, 'levels': contours}
    cf, c1 = pt.plot_difference_Bz(ax,
                                   Inversion.Bz_array, Inversion.inv_Bz_array,
                                   Inversion.Sx_range, Inversion.Sy_range,
                                   Inversion.Sdx, Inversion.Sdy,
                                   Inversion.particle_positions,
                                   contours=contours,
                                   dimension_scale=dimension_scale,
                                   data_scale=data_scale,
                                   contourf_args=contourf_args,
                                   imshow_args=imshow_args,
                                   scatter_args=scatter_args)

    return cf, c1
